/* 
The advantages of using documents are:

Documents (i.e. objects) correspond to native 
data types in many programming languages.

Embedded documents and arrays reduce need 
for expensive joins.

Dynamic schema supports fluent polymorphism.

Key Features

High Performance
MongoDB provides high performance data persistence. 
In particular,

Support for embedded data models reduces 
I/O activity on database system.

Indexes support faster queries and can include keys 
from embedded documents and arrays.

Horizontal Scalability
MongoDB provides horizontal scalability as part 
of its core functionality:

Sharding distributes data across a cluster of machines.
Starting in 3.4, MongoDB supports creating zones 
of data based on the shard key. 
In a balanced cluster, MongoDB directs 
reads and writes covered by a zone only 
to those shards inside the zone. 
See the Zones manual page for more information.

Collections are assigned an immutable UUID. 
The collection UUID remains the same across all 
members of a replica set and shards in a 
sharded cluster.

To retrieve the UUID for a collection, 
run either the listCollections command 
or the db.getCollectionInfos() method.


MongoDB supports creating read-only views 
from existing collections or other views. 
For example, you can:

Create a view that excludes private or confidential 
data from a collection of employee data.

Create a view that adds computed fields from a 
collection of metrics.

Create a view that joins data from two different 
related collections.

Each view has an associated aggregation pipeline 
against the source data. MongoDB computes the 
view contents by executing the aggregation 
on-demand during read operations. 
MongoDB executes read operations on views 
as part of the underlying aggregation pipeline.

db.runCommand( { create: <view>, viewOn: <source>, pipeline: <pipeline> } )


Capped collections are fixed-size collections 
that support high-throughput operations that 
insert and retrieve documents based on insertion order. 
Capped collections work in a way similar to 
circular buffers: once a collection fills its 
allocated space, it makes room for new documents 
by overwriting the oldest documents in the collection.

Consider the following potential use cases for capped collections:

Store log information generated by high-volume systems. 
Inserting documents in a capped collection without 
an index is close to the speed of writing 
log information directly to a file system. 
Furthermore, the built-in first-in-first-out 
property maintains the order of events, 
while managing storage use.

Cache small amounts of data in a capped collections. 
Since caches are read rather than write heavy, 
you would either need to ensure that this collection 
always remains in the working set (i.e. in RAM) or 
accept some write penalty for the required index 
or indexes.

size in bytes
db.createCollection("log", { capped : true, size : 5242880, max : 5000 } )
db.collection.isCapped()
db.runCommand({"convertToCapped": "mycoll", size: 100000});

Collation allows users to specify language-specific 
rules for string comparison, such as rules for 
lettercase and accent marks.
*/